- $$Rc<T> $$---用于单线程场景下的共享所有权
只提供对内部数据$$ T $$的不可变访问，你不能直接通过$$ Rc<T> $$获得$$\&mut~~ T$$

因为$$Rust $$的核心原则是每个值在任何时候都只有一个所有者
所以我们就要解决一个问题
如何让程序的多个部分都能拥有同一份堆上的数据，并确保数据在所有使用者都不再需要它之前一直存在
即，如何解决$$ Rust $$单一所有权原则下安全实现共享所有权的需求
如果使用普通的所有权转移，数据在转移后原来的位置就不能再访问了
如果使用普通的引用$$\&T$$，又会受到借用规则和生命周期的严格限制

我们可以将$$ Rc<T> $$的核心机制理解为包含两个主要部分
- $$Rc<T> $$结构体 (栈上或内嵌):
  - 这部分是你直接在代码中使用的类型$$ Rc<T>$$
  - 它本质上只包含一个指向堆上分配的内存块的指针
- $$RcBox<T> $$结构体 (堆上):
  - 这是通过$$ Rc::new(value) $$创建$$ Rc $$时在堆上实际分配的内存区域
  - 这个$$ RcBox<T> $$包含两个关键信息：
    - 强引用计数: 一个$$ usize$$，记录当前有多少个活跃的$$ Rc<T> $$指针指向这个$$ RcBox$$
    - 弱引用计数:同样是一个$$usize$$，用于支持$$ Weak<T> $$指针
    记录有多少个$$ Weak<T> $$指针存在，弱引用不影响数据$$ T $$的生存期，只用于打破引用循环
    也就是弱引用不保证所指向对象是否仍然存在
    - 数据:你实际想要共享的数据本身

1. 创建 ($$Rc::new(value: T)$$)
  - 在堆上分配一块足够容纳$$ RcBox<T>$$的内存
  - 将传入的$$ value $$$$move$$到这块堆内存的数据部分
  - 将堆内存中的强引用计数和弱引用初始化为$$ 1$$ 
  - 在栈上创建一个$$ Rc<T> $$结构体，使其内部指针指向刚刚在堆上分配的$$ RcBox<T>$$
  - 返回这个栈上的$$ Rc<T>$$
2. 创建强引用 ($$Rc::clone(this: \&Rc<T>)$$)
  - 获取$$ this $$内部指向堆上$$ RcBox<T> $$的指针
  - 关键： 访问堆上的$$ RcBox<T>$$，将其内部的强引用计数加$$ 1$$，弱引用计数不变
  - 在栈上创建一个新的$$ Rc<T> $$结构体
  - 将这个新的$$ Rc<T> $$的内部指针设置为与$$ this $$相同的值（即指向同一个堆上的$$ RcBox<T>$$）
  - 返回这个新的$$ Rc<T>$$
3. 创建弱引用 ($$Rc::downgrade(this: \&Rc<T>) -> Weak<T>$$)
  - 获取$$ this $$内部指向堆上$$ RcBox<T> $$的指针
  - 访问堆上的$$ RcBox<T>$$，将其内部的弱引用计数加$$ 1$$，强引用计数不变
  - 在栈上创建一个$$ Weak<T> $$结构体，其内部指针也指向同一个$$ RcBox<T>$$
  - 返回这个$$ Weak<T>$$
4. 使用弱引用 ($$Weak::upgrade(\&self) -> Option<Rc<T>>$$)
  - 由于$$ Weak<T> $$不保证指向的数据仍然存在，访问前必须调用$$ upgrade()$$
  - $$upgrade() $$检查堆上$$ RcBox<T> $$的强引用计数是否大于$$ 0$$
  - 如果$$ > 0$$，表示数据$$ T $$仍然有效
  此时$$ upgrade() $$会增加强引用计数，并返回一个包含新$$ Rc<T> $$指针的$$ Some(Rc<T>)$$
  你可以安全地通过这个临时的$$ Rc<T> $$访问数据
  当这个临时的$$ Rc<T> $$被$$ drop $$时，强引用计数会再次减少
  - 如果$$ == 0$$，表示数据$$ T $$已经被销毁，此时$$ upgrade() $$返回$$ None$$
5. 销毁强引用 (当一个$$ Rc<T> $$离开作用域时，其$$ Drop ~~trait $$实现被调用):
  - 获取该$$ Rc<T> $$内部指向堆上$$ RcBox<T> $$的指针
  - 访问堆上的$$ RcBox<T>$$，将其内部的强引用计数减$$ 1$$
  - 检查强引用计数：
    - 如果减$$ 1 $$后，强引用计数变为$$ 0$$
      - 这意味着这是最后一个指向该堆数据的强引用了
      - 首先，需要$$ drop $$存储在$$ RcBox<T> $$内部的数据$$ T $$本身（调用$$ T $$的$$ Drop $$实现）
      - 然后，将弱引用计数减$$ 1$$（移除代表强引用的那个初始弱计数）
      - 检查弱引用计数： 如果此时弱引用计数也变为$$ 0$$，则释放整个$$ RcBox<T> $$在堆上占用的内存
    - 如果减$$ 1 $$后，强引用计数仍大于$$ 0$$：
      - 还有其他强引用存在，只需减少计数即可，不做其他操作
6. 销毁弱引用 (当一个$$ Weak<T> $$离开作用域时，其$$ Drop ~~trait $$实现被调用):
  - 获取该$$ Weak<T> $$内部指向堆上$$ RcBox<T> $$的指针
  - 访问堆上的$$ RcBox<T>$$，将其内部的弱引用计数减$$ 1$$
  - 检查弱引用计数：
    - 如果减$$ 1 $$后，弱引用计数变为$$ 0 $$并且强引用计数也已经为$$ 0$$：
      - 释放整个$$ RcBox<T> $$在堆上占用的内存
    - 否则，不做其他操作

- 原子操作: 
原子操作是$$ CPU $$层面保证不可分割的操作
即使在多核、多线程环境下，当多个线程同时尝试对同一个原子变量进行读写时，这些操作也会以某种顺序依次完成，而不会出现中间状态被破坏或数据竞争的情况
例如，原子的读取-修改-写入操作（如$$ fetch\_add$$）可以保证计数的正确性
这通常需要特殊的$$ CPU $$指令支持，会有一定的性能开销
- 非原子操作: 就是普通的加减法
如果两个线程同时读取计数（比如都读到$$ 2$$），然后各自加$$ 1$$（都得到$$ 3$$），再写回内存（都写入$$ 3$$），最终结果是$$ 3$$，但实际上应该是$$ 4$$
这就导致了计数错误，可能导致内存被过早释放（悬垂指针）或永远不释放（内存泄漏）
因为$$ Rc<T> $$使用非原子操作来管理计数，所以它不是线程安全的
$$Rust $$的类型系统通过不允许$$ Rc<T> $$实现$$ Send $$和$$ Sync~~ trait $$来阻止你在多线程间安全地共享它

而且$$Rc$$也会产生一个严重的内存泄漏问题，即引用循环
use std::rc::Rc;
use std::cell::RefCell; // 需要 RefCell 来在创建后修改内部 Rc

struct A {
    name: String,
    b: RefCell<Option<Rc<B>>>, // A 持有指向 B 的 Rc
}

struct B {
    name: String,
    a: RefCell<Option<Rc<A>>>, // B 持有指向 A 的 Rc
}

fn main() {
    // 1. 创建 A 实例，初始强引用计数为 1
    let a = Rc::new(A {
        name: "Alice".to_string(),
        b: RefCell::new(None),
    });
    println!("Initial A strong count = {}", Rc::strong_count(&a)); // 输出 1

    // 2. 创建 B 实例，初始强引用计数为 1
    let b = Rc::new(B {
        name: "Bob".to_string(),
        a: RefCell::new(None),
    });
    println!("Initial B strong count = {}", Rc::strong_count(&b)); // 输出 1

    println!("--- Creating the cycle ---");

    // 3. 让 A 指向 B (通过克隆 Rc<B>)
    *a.b.borrow_mut() = Some(Rc::clone(&b));
    println!("A points to B:");
    println!("  A strong count = {}", Rc::strong_count(&a)); // 仍为 1 (a 变量持有)
    println!("  B strong count = {}", Rc::strong_count(&b)); // 变为 2 (b 变量 + A 内部持有)

    // 4. 让 B 指向 A (通过克隆 Rc<A>) - 形成循环！
    *b.a.borrow_mut() = Some(Rc::clone(&a));
    println!("B points to A (Cycle formed):");
    println!("  A strong count = {}", Rc::strong_count(&a)); // 变为 2 (a 变量 + B 内部持有)
    println!("  B strong count = {}", Rc::strong_count(&b)); // 仍为 2 (b 变量 + A 内部持有)

    println!("--- End of main scope ---");
    // main 函数结束，变量 a 和 b 离开作用域
} // drop(b) 被调用, drop(a) 被调用

- $$Arc<T>$$--用于多线程场景下的共享所有权
解决的问题很简单，就是为了解决$$Rc$$无法安全在多线程下使用
与$$Rc$$一样，只提供对内部数据$$ T $$的不可变访问，你不能直接通过$$ Arc<T> $$获得$$\&mut~~ T$$
操作也几乎与$$Rc$$一样，只是计数从$$usize$$改成了原子类型，操作也全部使用原子操作